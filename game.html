<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <style>
        html, body {
            margin: 0;
            padding: 0;

            width: 100%;
            height: 100%;

            overflow: hidden;
        }
    </style>
</head>
<body>
    <script src='jquery.min.js'></script>
    <script src='cannon.min.js'></script>
    <script src='three.min.js'></script>
    <script src='game.mode.js'></script>
    <script src='game.physics.js'></script>
    <script src='game.scene.js'></script>
    <script>
        'use strict';

        var game = testGameMode();

        // controlling

        var keyMap = {};
        var keyAD = 0;
        var keyWS = 0;
        var mouseLR = 0;
        var mouseTB = 0;

        $('body').keydown(function (event) {
            keyMap[event.which] = true;
        });
        $('body').keyup(function (event) {
            keyMap[event.which] = false;
        });
        $('body').mousemove(function (event) {
            mouseLR = 1 - 2 * event.offsetX / $('body').width();
            mouseTB = 2 * event.offsetY / $('body').height() - 1;
        });

        // game

        var world = new GameWorld(game, function () {
            var mat = new CANNON.Material();
            var mat2 = new CANNON.Material();

            var shape = new CANNON.Sphere(1);
            var body = new CANNON.Body({
                mass: 1, material: mat, shape: shape
            }); // mass

            this.addBody(body);
            this.testBody = body;

            var shape2 = new CANNON.Sphere(1);
            var body2 = new CANNON.Body({
                mass: 3, material: mat2, shape: shape2
            }); // mass
            body2.position.set(0.00001, -30, 0);

            this.addBody(body2);
            this.testBody2 = body2;

            this.addMaterial(mat);
            this.addMaterial(mat2);
            this.addContactMaterial(
                new CANNON.ContactMaterial(mat, mat2)
            );

            // testing
            body.velocity.set(0, -20, 0);
        }, function () {
            //
        }, function () {
            var hasA = keyMap['A'.charCodeAt()];
            var hasD = keyMap['D'.charCodeAt()];
            var hasW = keyMap['W'.charCodeAt()];
            var hasS = keyMap['S'.charCodeAt()];

            if (hasA || (!hasD && keyAD < 0)) {
                keyAD = Math.min(keyAD + 1, 20);
            }
            if (hasD || (!hasA && keyAD > 0)) {
                keyAD = Math.max(keyAD - 1, -20);
            }
            if (hasW || (!hasS && keyWS < 0)) {
                keyWS = Math.min(keyWS + 1, 20);
            }
            if (hasS || (!hasW && keyWS > 0)) {
                keyWS = Math.max(keyWS - 1, -20);
            }

            document.title = 0.05 * keyAD + ' ' + 0.05 * keyWS

            return {
                0: {
                    // up-down
                    yz: mouseTB,
                    // left-right
                    zx: 0.05 * keyAD,
                    // rolling
                    xy: mouseLR,
                    // front-back
                    force: 0.05 * keyWS,
                }
            };
        });

        // scene

        var scene = new GameScene('body', function (handler) {
            $(window).resize(handler);
        }, game, function () {
            var geometry = new THREE.SphereGeometry(1, 16, 16);
            var material = new THREE.MeshLambertMaterial({
                color: 0x808080,
                map: THREE.ImageUtils.loadTexture('background.jpg'),
            });
            var object = new THREE.Mesh(geometry, material);

            this.add(object);
            this.testObject = object;

            var object2 = new THREE.Mesh(geometry, material);

            this.add(object2);
            this.testObject2 = object2;
        }, function () {
            world.simulate();

            var delta = 0.001 * (world.timeNow - world.timeSim);

            this.testObject.position.copy(world.testBody.predictPosition(delta));
            this.testObject.rotation.setFromVector3(world.testBody.predictRotation(delta), 'YZX');
            this.testObject2.position.copy(world.testBody2.predictPosition(delta));
            this.testObject2.rotation.setFromVector3(world.testBody2.predictRotation(delta), 'YZX');
        });
    </script>
</body>
</html>
